---------------

Versão de Prototype_case4:

Método para encontrar uma boa solução viável:
	- Inicialmente, checa todos os conjuntos com quantidade de X = 2.
	- Feito isso, vê quais deles tem o maior coeficiente.
	- Se todos os coeficientes de 2 forem negativos, considera todos os casos onde
		dois coeficientes são iguais a 0.
	- Os conjuntos de 2 valores maiores possíveis são soluções viáveis.
		 
Relaxação:
	- Soma dos coeficientes de x=1 do conjunto que são indeterminados ou positivos.
	
Critério de particionamento do espaço de soluções (branch):
	- A partir de xi, i=1, cada subsolução gera um filho, com xi = true.
	
- Bound:
	- Soma o valor atual de todos e faz média.
	- Corta todos aqueles abaixo dessa média.
	(Próxima versão: passar a calcular o higher (pq queremos maximizar)
	 bound de subespaços futuros)
	 (o código pra isso já está mais ou menos pronto no higher_bound, falta melhorar)

Percorrendo o espaço de soluções:
	- xi, i=1 a quantidade de x.
	
Critério de seleção do particionamento:
	- Busca em largura.
	
Melhoras para case_5:
	- Melhorar o bound.
	- Na geração de filhos, trocar a geração adicionando 1 ao x por uma
		inversão do x em questão pro primeiro filho.
		
Melhoras para case_6:
	- Adicionar caminhada pelos nós em questão, ao invés de setar em ordem os x,
	porquê a partir do momento em que eu não começo do 0,
	a inversão me faz andar mais de uma vez em x.
	(Espero que dê para não precisar efetivamente programar uma árvore,
	se o bound for bom...)
